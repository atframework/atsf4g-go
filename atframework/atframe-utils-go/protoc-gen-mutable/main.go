package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GoTypeString 返回该字段在生成的 Go 代码中的类型名（字符串形式）
func GoTypeString(g *protogen.GeneratedFile, f *protogen.Field, withoutPointer bool) string {
	// map
	if f.Desc.IsMap() {
		keyField := f.Message.Fields[0]
		valField := f.Message.Fields[1]
		keyType := scalarGoType(keyField)
		valType := elementGoType(g, valField, false)
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}

	// repeated
	if f.Desc.IsList() {
		elemType := elementGoType(g, f, false)
		return "[]" + elemType
	}

	// 单值
	return elementGoType(g, f, withoutPointer)
}

// elementGoType 返回字段元素（非 repeated）的 Go 类型
func elementGoType(g *protogen.GeneratedFile, f *protogen.Field, withoutPointer bool) string {
	switch f.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.EnumKind:
		// Enum 类型直接返回枚举名
		return g.QualifiedGoIdent(f.Enum.GoIdent)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		// Message 类型生成的 Go 字段通常是指针
		if withoutPointer {
			return g.QualifiedGoIdent(f.Message.GoIdent)
		}
		return "*" + g.QualifiedGoIdent(f.Message.GoIdent)
	default:
		return "interface{}"
	}
}

// scalarGoType 返回 map key 的 Go 基础类型
func scalarGoType(f *protogen.Field) string {
	switch f.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	default:
		return "interface{}"
	}
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}
			generateFile(plugin, f)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, f *protogen.File) {
	filename := f.GeneratedFilenamePrefix + "_mutable.pb.go"
	g := plugin.NewGeneratedFile(filename, f.GoImportPath)

	g.P("// Code generated by protoc-gen-mutable. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()
	if len(f.Messages) != 0 {
		g.P("import \"google.golang.org/protobuf/proto\"")
		g.P()
	}

	for _, msg := range f.Messages {
		generateMutableForMessage(g, msg)
	}
}

func generateMutableForMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	if msg.Desc.IsMapEntry() {
		return
	}

	g.P("// ===== Clone methods for ", msg.GoIdent.GoName, " ===== Message ====")
	g.P(fmt.Sprintf(`func (m *%s) Clone() *%s {`, msg.GoIdent.GoName, msg.GoIdent.GoName))
	g.P(`  if m == nil {`)
	g.P(fmt.Sprintf(`    return new(%s)`, msg.GoIdent.GoName))
	g.P(`  }`)
	g.P(fmt.Sprintf(`  return proto.Clone(m).(*%s)`, msg.GoIdent.GoName))
	g.P(`}`)
	g.P()

	for _, field := range msg.Fields {
		fieldName := field.GoName
		switch {
		case field.Desc.IsMap():
			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Map =====")
			fieldType := GoTypeString(g, field, false)
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() %s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = make(%s, 0)`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()
		case field.Desc.IsList():
			fieldType := GoTypeString(g, field, false)
			elementType := elementGoType(g, field, false)

			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() %s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== ReverseIfNil methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) ReverseIfNil%s(l int32) %s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = make(%s, 0, l)`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== Append methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) Append%s(d %s) {`, msg.GoIdent.GoName, fieldName, elementType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`    m.%s = append(m.%s, d)`, fieldName, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== Merge methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) Merge%s(d %s) %s {`, msg.GoIdent.GoName, fieldName, fieldType, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`    m.%s = append(m.%s, d...)`, fieldName, fieldName))
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== RemoveLast methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) RemoveLast%s() {`, msg.GoIdent.GoName, fieldName))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  if len(m.%s) != 0 {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = m.%s[:len(m.%s)-1]`, fieldName, fieldName, fieldName))
			g.P(`}`)
			g.P(`}`)
			g.P()
		case field.Oneof != nil:
			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Oneof =====")

			generateMutableForOneof(g, msg, field, fieldName)
		case field.Message != nil:
			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Message =====")
			fieldType := GoTypeString(g, field, true)
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() *%s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = new(%s)`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()
		default:
			// 基本类型不生成 Mutable 方法
		}
	}
	g.P()
	for _, nested := range msg.Messages {
		generateMutableForMessage(g, nested)
	}
}

func generateMutableForOneof(g *protogen.GeneratedFile, msg *protogen.Message, field *protogen.Field, fieldName string) {
	oneofName := field.Oneof.GoName
	fullFieldName := fmt.Sprintf("%s_%s", msg.GoIdent.GoName, fieldName)
	g.P(fmt.Sprintf(`func (m *%s) Mutable%s() *%s {`, msg.GoIdent.GoName, fieldName, fullFieldName))
	g.P(fmt.Sprintf(`  if x, ok := m.%s.(*%s); ok {`, oneofName, fullFieldName))
	g.P(`    return x`)
	g.P(`  }`)
	g.P(fmt.Sprintf(`  x := new(%s)`, fullFieldName))
	g.P(fmt.Sprintf(`  m.%s = x`, oneofName))
	g.P(`  return x`)
	g.P(`}`)
	g.P()
}
