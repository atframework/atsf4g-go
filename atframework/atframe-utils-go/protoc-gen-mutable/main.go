package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GoTypeString 返回该字段在生成的 Go 代码中的类型名（字符串形式）
func GoTypeString(g *protogen.GeneratedFile, f *protogen.Field, withoutPointer bool) string {
	// map
	if f.Desc.IsMap() {
		keyField := f.Message.Fields[0]
		valField := f.Message.Fields[1]
		keyType := scalarGoType(keyField)
		valType := elementGoType(g, valField, false)
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}

	// repeated
	if f.Desc.IsList() {
		elemType := elementGoType(g, f, false)
		return "[]" + elemType
	}

	// 单值
	return elementGoType(g, f, withoutPointer)
}

// elementGoType 返回字段元素（非 repeated）的 Go 类型
func elementGoType(g *protogen.GeneratedFile, f *protogen.Field, withoutPointer bool) string {
	switch f.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.EnumKind:
		// Enum 类型直接返回枚举名
		return g.QualifiedGoIdent(f.Enum.GoIdent)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		// Message 类型生成的 Go 字段通常是指针
		if withoutPointer {
			return g.QualifiedGoIdent(f.Message.GoIdent)
		}
		return "*" + g.QualifiedGoIdent(f.Message.GoIdent)
	default:
		return "interface{}"
	}
}

// scalarGoType 返回 map key 的 Go 基础类型
func scalarGoType(f *protogen.Field) string {
	switch f.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	default:
		return "interface{}"
	}
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}
			generateFile(plugin, f)
		}
		return nil
	})
}

var initGenerate []string

func generateFile(plugin *protogen.Plugin, f *protogen.File) {
	filename := f.GeneratedFilenamePrefix + "_mutable.pb.go"
	g := plugin.NewGeneratedFile(filename, f.GoImportPath)

	g.P("// Code generated by protoc-gen-mutable. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()
	if len(f.Messages) != 0 {
		g.P("import \"google.golang.org/protobuf/proto\"")
		g.P("import \"log/slog\"")
		g.P("import pu \"github.com/atframework/atframe-utils-go/proto_utility\"")
		g.P()
	}

	for _, msg := range f.Messages {
		if findOneofForMessage(msg) {
			g.P("import \"reflect\"")
			g.P()
			break
		}
	}

	for _, msg := range f.Messages {
		generateMutableForMessage(g, msg)
	}

	if len(initGenerate) != 0 {
		g.P("func init() {")
		for _, initCode := range initGenerate {
			g.P(initCode)
		}
		g.P("}")
		g.P()
	}
	initGenerate = nil
}

func findOneofForMessage(msg *protogen.Message) bool {
	if msg.Desc.IsMapEntry() {
		return false
	}

	if len(msg.Oneofs) != 0 {
		return true
	}

	for _, nested := range msg.Messages {
		if findOneofForMessage(nested) {
			return true
		}
	}

	return false
}

func generateMutableForMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	if msg.Desc.IsMapEntry() {
		return
	}

	g.P("// ===== Clone methods for ", msg.GoIdent.GoName, " ===== Message ====")
	g.P(fmt.Sprintf(`func (m *%s) Clone() *%s {`, msg.GoIdent.GoName, msg.GoIdent.GoName))
	g.P(`  if m == nil {`)
	g.P(fmt.Sprintf(`    return new(%s)`, msg.GoIdent.GoName))
	g.P(`  }`)
	g.P(fmt.Sprintf(`  return proto.Clone(m).(*%s)`, msg.GoIdent.GoName))
	g.P(`}`)
	g.P()

	g.P("// ===== Merge methods for ", msg.GoIdent.GoName, " ===== Message ====")
	g.P(fmt.Sprintf(`func (m *%s) Merge(src *%s) {`, msg.GoIdent.GoName, msg.GoIdent.GoName))
	g.P(`  if m == nil {`)
	g.P(`    return`)
	g.P(`  }`)
	g.P(`  proto.Merge(m, src)`)
	g.P(`}`)
	g.P()

	g.P("// ===== SlogValue methods for ", msg.GoIdent.GoName, " ===== Message ====")
	g.P(fmt.Sprintf(`func (m *%s) LogValue() slog.Value {`, msg.GoIdent.GoName))
	g.P(`  return slog.StringValue(pu.MessageReadableText(m))`)
	g.P(`}`)
	g.P()

	for _, oneof := range msg.Oneofs {
		oneofName := oneof.GoName

		g.P("// ===== Case Enum for ", msg.GoIdent.GoName, " Oneof ", oneofName, " ===== Oneof =====")
		g.P(fmt.Sprintf(`type %s_En%sID int32`, msg.GoIdent.GoName, oneofName))
		g.P("const (")
		g.P(fmt.Sprintf(`	%s_En%sID_%s %s_En%sID = 0 // none`, msg.GoIdent.GoName, oneofName, "NONE", msg.GoIdent.GoName, oneofName))
		for _, o := range oneof.Fields {
			g.P(fmt.Sprintf(`	%s_En%sID_%s %s_En%sID = %d // %s`, msg.GoIdent.GoName, oneofName, o.GoName, msg.GoIdent.GoName, oneofName, o.Desc.Number(), o.Desc.TextName()))
		}
		g.P(")")
		g.P()

		g.P("// ===== GetCase interface for ", msg.GoIdent.GoName, " Oneof ", oneofName, " ===== Oneof =====")
		g.P(fmt.Sprintf(`type get%s_%s interface {`, msg.GoIdent.GoName, oneofName))
		g.P(fmt.Sprintf(`	Get%s_%s() %s_En%sID`, msg.GoIdent.GoName, oneofName, msg.GoIdent.GoName, oneofName))
		g.P("}")
		g.P()

		g.P("// ===== GetCase methods for ", msg.GoIdent.GoName, " Oneof ", oneofName, " ===== Oneof =====")
		g.P(fmt.Sprintf(`func (m *%s) Get%sOneofCase() %s_En%sID {`, msg.GoIdent.GoName, oneofName, msg.GoIdent.GoName, oneofName))
		g.P(`  if m == nil {`)
		g.P(`    return 0`)
		g.P(`  }`)
		g.P(fmt.Sprintf(`	return m.%s.(get%s_%s).Get%s_%s()`, oneofName, msg.GoIdent.GoName, oneofName, msg.GoIdent.GoName, oneofName))
		g.P(`}`)
		g.P()
	}

	for _, field := range msg.Fields {
		fieldName := field.GoName
		switch {
		case field.Desc.IsMap():
			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Map =====")
			fieldType := GoTypeString(g, field, false)
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() %s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = make(%s, 0)`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()
		case field.Desc.IsList():
			fieldType := GoTypeString(g, field, false)
			elementType := elementGoType(g, field, false)

			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() %s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== ReverseIfNil methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) ReverseIfNil%s(l int32) %s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = make(%s, 0, l)`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== Append methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) Append%s(d %s) {`, msg.GoIdent.GoName, fieldName, elementType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`    m.%s = append(m.%s, d)`, fieldName, fieldName))
			g.P(`}`)
			g.P()

			if field.Message != nil {
				// Message Add
				g.P("// ===== Add methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
				g.P(fmt.Sprintf(`func (m *%s) Add%s() %s {`, msg.GoIdent.GoName, fieldName, elementType))
				g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
				g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
				g.P(`  }`)
				g.P(fmt.Sprintf(`  addValue := new(%s)`, elementGoType(g, field, true)))
				g.P(fmt.Sprintf(`    m.%s = append(m.%s, addValue)`, fieldName, fieldName))
				g.P(`	return addValue`)
				g.P(`}`)
				g.P()
			}

			g.P("// ===== Merge methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) Merge%s(d %s) %s {`, msg.GoIdent.GoName, fieldName, fieldType, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`    m.%s = append(m.%s, d...)`, fieldName, fieldName))
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== RemoveLast methods for ", msg.GoIdent.GoName, " ===== Repeated =====")
			g.P(fmt.Sprintf(`func (m *%s) RemoveLast%s() {`, msg.GoIdent.GoName, fieldName))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = %s{}`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  if len(m.%s) != 0 {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = m.%s[:len(m.%s)-1]`, fieldName, fieldName, fieldName))
			g.P(`}`)
			g.P(`}`)
			g.P()
		case field.Oneof != nil:
			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Oneof =====")
			oneofName := field.Oneof.GoName
			fullFieldName := fmt.Sprintf("%s_%s", msg.GoIdent.GoName, fieldName)
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() *%s {`, msg.GoIdent.GoName, fieldName, fullFieldName))
			g.P(fmt.Sprintf(`  if x, ok := m.%s.(*%s); ok {`, oneofName, fullFieldName))
			g.P(`    return x`)
			g.P(`  }`)
			g.P(fmt.Sprintf(`  x := new(%s)`, fullFieldName))
			g.P(fmt.Sprintf(`  m.%s = x`, oneofName))
			g.P(`  return x`)
			g.P(`}`)
			g.P()

			g.P("// ===== Oneof Interface for ", msg.GoIdent.GoName, " Oneof ", fullFieldName, " ===== Oneof =====")
			g.P(fmt.Sprintf(`func (m *%s) Get%s_%s() %s_En%sID {`, fullFieldName, msg.GoIdent.GoName, oneofName, msg.GoIdent.GoName, oneofName))
			g.P(fmt.Sprintf(`  return %s_En%sID_%s`, msg.GoIdent.GoName, oneofName, fieldName))
			g.P(`}`)
			g.P()

			g.P("// ===== Get reflect Type for ", msg.GoIdent.GoName, " Oneof ", oneofName, " ===== Oneof =====")
			g.P(fmt.Sprintf(`	var ReflectType%s reflect.Type`, fullFieldName))
			g.P(fmt.Sprintf(`func GetReflectType%s() reflect.Type {`, fullFieldName))
			g.P(fmt.Sprintf(`	return ReflectType%s`, fullFieldName))
			g.P(`}`)
			g.P()
			initGenerate = append(initGenerate, fmt.Sprintf(`	ReflectType%s = reflect.TypeOf((*%s)(nil)).Elem()`, fullFieldName, fullFieldName))
		case field.Message != nil:
			g.P("// ===== Mutable methods for ", msg.GoIdent.GoName, " ===== Message =====")
			fieldType := GoTypeString(g, field, true)
			g.P(fmt.Sprintf(`func (m *%s) Mutable%s() *%s {`, msg.GoIdent.GoName, fieldName, fieldType))
			g.P(fmt.Sprintf(`  if m.%s == nil {`, fieldName))
			g.P(fmt.Sprintf(`    m.%s = new(%s)`, fieldName, fieldType))
			g.P(`  }`)
			g.P(fmt.Sprintf(`  return m.%s`, fieldName))
			g.P(`}`)
			g.P()
		default:
			// 基本类型不生成 Mutable 方法
		}
	}

	for _, nested := range msg.Messages {
		generateMutableForMessage(g, nested)
	}
}
