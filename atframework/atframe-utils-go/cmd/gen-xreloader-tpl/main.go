package main

import (
	"fmt"
	"html/template"
	"os"
	"path"
	"path/filepath"
)

// 常量定义.
const (
	// 必需参数个数.
	requiredArgsCount = 5
	// 默认输出目录.
	defaultOutputDir = "."
	// 目录权限.
	dirPermission = 0o750
	// 文件权限 (0o600 = read+write for owner only).
	filePermission = 0o600
)

// copyFile 拷贝单个文件.
func copyFile(src, dst string) error {
	// 读取源文件
	// #nosec G304
	data, err := os.ReadFile(src)
	if err != nil {
		return fmt.Errorf("failed to read source file %s: %w", src, err)
	}

	// 写入目标文件
	// #nosec G306
	if err := os.WriteFile(dst, data, filePermission); err != nil {
		return fmt.Errorf("failed to write destination file %s: %w", dst, err)
	}

	return nil
}

// XresloaderXMLVar 包含 xresloader 配置模板的参数.
type XresloaderXmlVar struct {
	XRESCONV_XML_PATH     string
	XRESCONV_EXE_PATH     string
	XRESCONV_CONFIG_PB    string
	XRESCONV_BYTES_OUTPUT string
	XRESCONV_EXECL_SRC    string
}

// GenerateXresloaderTemplate 根据模板和参数生成 xresconv.xml 文件并拷贝 validator.yaml.
func GenerateXresloaderTemplate(templatePath string, resourcePath string,
	vars XresloaderXmlVar, outputDir string) error {
	// 验证输入参数
	if err := validatePath(templatePath, "template_path"); err != nil {
		return err
	}
	if err := validatePath(outputDir, "output_dir"); err != nil {
		return err
	}

	// 验证输出目录
	if err := os.MkdirAll(outputDir, dirPermission); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// 验证模板文件存在
	if _, err := os.Stat(templatePath); err != nil {
		return fmt.Errorf("template file not found at %s: %w", templatePath, err)
	}

	// 解析模板
	tmpl, err := template.ParseFiles(templatePath)
	if err != nil {
		return fmt.Errorf("error parsing template: %w", err)
	}

	// 输出文件路径构建
	// outputXML 由经过验证的 outputDir 和常量文件名构成。 #nosec G304
	outputFile, err := os.Create(path.Join(outputDir, "xresconv.xml"))
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}

	defer func() {
		if cerr := outputFile.Close(); cerr != nil {
			fmt.Fprintf(os.Stderr, "warning: error closing output file: %v\n", cerr)
		}
	}()

	// 执行模板并将输出写入文件
	err = tmpl.Execute(outputFile, vars)
	if err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	fmt.Printf("✓ Template generated successfully \n")

	// 拷贝 validator.yaml
	if err := CopyValidatorYAML(resourcePath, outputDir); err != nil {
		return err
	}

	return nil
}

// CopyValidatorYAML 拷贝 validator.yaml 文件.
func CopyValidatorYAML(resourcePath string, outputDir string) error {
	srcPath := filepath.Join(resourcePath, "validator.yaml")
	dstPath := filepath.Join(outputDir, "validator.yaml")

	// 验证源文件存在
	if _, err := os.Stat(srcPath); err != nil {
		return fmt.Errorf("validator.yaml not found at %s: %w", srcPath, err)
	}

	// 拷贝文件
	if err := copyFile(srcPath, dstPath); err != nil {
		return fmt.Errorf("failed to copy validator.yaml: %w", err)
	}

	fmt.Printf("✓ validator.yaml copied to %s\n", dstPath)
	return nil
}

// validatePath 验证路径的安全性.
func validatePath(p string, name string) error {
	// 检查路径是否为空
	if p == "" {
		return fmt.Errorf("%s cannot be empty", name)
	}

	// 验证路径是否存在
	if _, err := os.Stat(p); os.IsNotExist(err) {
		return fmt.Errorf("%s does not exist: %s", name, p)
	}

	return nil
}

// printUsage 打印使用说明.
func printUsage() {
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "=== Xresloader Template Generator ===\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "Usage:\n")
	fmt.Fprintf(os.Stderr, "  go run . <template_path> <resource_path> <xresconv_xml_path> <xresconv_exe_path>\n")
	fmt.Fprintf(os.Stderr, "    <config_pb> <bytes_output> <excel_src> [output_dir]\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "Arguments:\n")
	fmt.Fprintf(os.Stderr, "  template_path       Path to xresconv.xml template file (required)\n")
	fmt.Fprintf(os.Stderr, "  resource_path       Path to resource directory containing validator.yaml (required)\n")
	fmt.Fprintf(os.Stderr, "  xresconv_xml_path   Path to xresconv.xml configuration file (required)\n")
	fmt.Fprintf(os.Stderr, "  xresconv_exe_path   Path to xresloader executable binary (required)\n")
	fmt.Fprintf(os.Stderr, "  config_pb           Path to protobuf config file, typically public-config.pb (required)\n")
	fmt.Fprintf(os.Stderr, "  bytes_output        Output directory for generated bytes files (required)\n")
	fmt.Fprintf(os.Stderr, "  excel_src           Path to Excel resource directory containing data files (required)\n")
	fmt.Fprintf(os.Stderr, "  output_dir          Output directory for generated xresconv.xml\n")
	fmt.Fprintf(os.Stderr, "                      (optional, default: current directory)\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "Example:\n")
	fmt.Fprintf(os.Stderr, "   go run .  ./tools/xresconv.xml.tpl ./resource \\\n")
	fmt.Fprintf(os.Stderr, "    ./resource/xresconv.xml ./tools/bin/xresloader \\\n")
	fmt.Fprintf(os.Stderr, "    ./build/pbdesc/public-config.pb ./build/bytes ./resource/ExcelTables ./output\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "Note:\n")
	fmt.Fprintf(os.Stderr, "  - All paths will be converted to absolute paths internally\n")
	fmt.Fprintf(os.Stderr, "  - The output directory will be created if it does not exist\n")
	fmt.Fprintf(os.Stderr, "  - Template file should be a Go html/template format\n")
	fmt.Fprintf(os.Stderr, "  - validator.yaml will be copied from resource_path to output_dir\n")
	fmt.Fprintf(os.Stderr, "\n")
}

func main() {
	if len(os.Args) < requiredArgsCount+2 {
		printUsage()
		os.Exit(1)
	}

	// for idx, arg := range os.Args {
	// 	fmt.Printf("=== os.Args[%d] === %v \n", idx, arg)
	// }

	// 解析参数
	templatePath := os.Args[1]
	resourcePath := os.Args[2]
	xmlPath := os.Args[3]
	exePath := os.Args[4]
	configPb := os.Args[5]
	bytesOutput := os.Args[6]
	excelSrc := os.Args[7]

	outputDir := defaultOutputDir
	if len(os.Args) > requiredArgsCount+2 {
		outputDir = os.Args[8]
	}

	// 创建模版变量结构
	vars := XresloaderXmlVar{
		xmlPath,
		exePath,
		configPb,
		bytesOutput,
		excelSrc,
	}

	// 生成模版
	if err := GenerateXresloaderTemplate(templatePath, resourcePath, vars, outputDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	os.Exit(0)
}
