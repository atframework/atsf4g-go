// Copyright 2025 atframework
package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"

	utils_template "github.com/atframework/atframe-utils-go/template"
	project_settings "github.com/atframework/atsf4g-go/tools/project-settings"
)

var initTemplate = `# This file is generated by tools/generate-for-pb tool.
configure:
  encoding: "UTF-8"
  output_directory: "{{ .project_build_dir }}"
  overwrite: false # overwrite file if it's already exists
  paths: []
  package_prefix: []
  protocol_input_pb_file: "{{ .protocol_input_pb_file }}"
  protocol_project_directory: "{{ .project_root_dir }}"
{{- with .protocol_external_pb_files }}
  protocol_external_pb_files: # external pb fils to load
  {{- range $_, $value := . }}
    - "{{ $value }}"
  {{- end }}
{{- end }}
{{- if not (empty .custom_variables) }}
  {{- with .custom_variables }}
  custom_variables:
    {{- range $key, $value := .custom_variables }}
    "{{ $key }}" : "{{ $value }}"
    {{- end }}
  {{- end }}
{{- end }}

rules:
{{- range $key, $value := .rules }}
  # rule for {{ $key }}
  {{- $value | trim | nindent 2 }}
{{- end }}
`

var basicTemplate *template.Template

func getBasicTemplate() *template.Template {
	if basicTemplate != nil {
		return basicTemplate
	}

	basicTemplate = template.New("generate-for-pb").Funcs(utils_template.TemplateFuncMap())
	return basicTemplate
}

func renderServiceSettings(serviceTemplateFile string, rules *map[string]string) error {
	tmpl, err := template.ParseFiles(serviceTemplateFile)
	if err != nil {
		fmt.Printf("Failed to parse template file: %s\nerror: %v\n", serviceTemplateFile, err.Error())
		return err
	}

	output := new(bytes.Buffer)
	err = tmpl.Execute(output, map[string]interface{}{
		"project_root_dir":               strings.ReplaceAll(project_settings.GetProjectRootDir(), "\\", "/"),
		"project_build_dir":              strings.ReplaceAll(project_settings.GetProjectBuildDir(), "\\", "/"),
		"project_namespace":              project_settings.GetProjectPackageName(),
		"project_current_configure_dir":  strings.ReplaceAll(filepath.Dir(serviceTemplateFile), "\\", "/"),
		"project_current_configure_file": serviceTemplateFile,
		"project_template_dir":           strings.ReplaceAll(project_settings.GetProjectTemplateDir(), "\\", "/"),
	})
	if err != nil {
		fmt.Printf("Failed to parse template file: %s\nerror: %v\n", serviceTemplateFile, err.Error())
		return err
	}

	(*rules)[serviceTemplateFile] = output.String()
	return nil
}

func writeFinalSettings(outputFile *os.File, rules *map[string]string) error {
	pbDir := filepath.Join(project_settings.GetProjectResourceTargetDir(), "pbdesc")

	pbFiles := []string{}
	err := filepath.WalkDir(pbDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			fmt.Printf("Failed to access path: %s\nerror: %v\n", path, err.Error())
			return err
		}

		if d.IsDir() {
			return nil
		}

		if filepath.Ext(d.Name()) == ".pb" {
			pbFiles = append(pbFiles, strings.ReplaceAll(path, "\\", "/"))
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to walk directory: %w", err)
	}

	if len(pbFiles) == 0 {
		return fmt.Errorf("no .pb files found in directory: %s", pbDir)
	}

	tmpl, err := getBasicTemplate().Parse(initTemplate)
	if err != nil {
		return nil
	}

	output := new(bytes.Buffer)
	err = tmpl.Execute(output, map[string]interface{}{
		"project_root_dir":           strings.ReplaceAll(project_settings.GetProjectRootDir(), "\\", "/"),
		"project_build_dir":          strings.ReplaceAll(project_settings.GetProjectBuildDir(), "\\", "/"),
		"protocol_input_pb_file":     strings.ReplaceAll(pbFiles[0], "\\", "/"),
		"protocol_external_pb_files": pbFiles[1:],
		"custom_variables":           map[string]string{},
		"rules":                      rules,
	})
	if err != nil {
		return err
	}

	_, err = outputFile.Write(output.Bytes())
	return err
}

func collectGenerateForPbTemplateFiles(scanDirs []string) []string {
	var templateFiles []string
	cache := make(map[string]bool)
	for _, dir := range scanDirs {
		err := filepath.WalkDir(dir, func(path string, d os.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				return nil
			}
			if !strings.HasPrefix(d.Name(), "generate-for-pb.atfw.") || !(strings.HasSuffix(d.Name(), ".yaml.tpl") || strings.HasSuffix(d.Name(), ".yml.tpl")) {
				return nil
			}

			if _, ok := cache[path]; !ok {
				cache[path] = true
				templateFiles = append(templateFiles, strings.ReplaceAll(path, "\\", "/"))
			}

			return nil
		})
		if err != nil {
			fmt.Println("Failed to scan directory: ", dir, " error: ", err.Error())
			return nil
		}
	}

	slices.SortFunc(templateFiles, func(a, b string) int {
		ba := filepath.Base(a)
		bb := filepath.Base(b)
		if ba != bb {
			return strings.Compare(ba, bb)
		}

		return strings.Compare(a, b)
	})
	return templateFiles
}

func main() {
	outputFilePath := filepath.Join(project_settings.GetProjectGenDir(), "generate-for-pb.yaml")
	outputFile, err := os.OpenFile(outputFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o664)
	if err != nil {
		fmt.Printf("Open file: %s failed.\n%v\n", outputFilePath, err.Error())
		fmt.Println("Usage: go run generate-for-pb [<scan_dir> ...]")
		os.Exit(1)
		return
	}

	var scanDirs []string
	rules := make(map[string]string)
	if len(os.Args) < 2 {
		scanDirs = []string{filepath.Join(project_settings.GetProjectRootDir(), "src")}
	} else {
		scanDirs = os.Args[1:]
	}

	serviceTemplateFiles := collectGenerateForPbTemplateFiles(scanDirs)
	for _, serviceTemplateFile := range serviceTemplateFiles {
		fmt.Printf("Processing template file: %s\n", serviceTemplateFile)
		renderServiceSettings(serviceTemplateFile, &rules)
	}

	if err := writeFinalSettings(outputFile, &rules); err != nil {
		fmt.Printf("Failed to write file: %s\n%v\n", outputFilePath, err.Error())

		fmt.Println("Usage: go run generate-for-pb [<scan_dir> ...]")
		os.Exit(1)
		return
	}

	fmt.Printf("Write file: %s success\n", outputFilePath)
}
