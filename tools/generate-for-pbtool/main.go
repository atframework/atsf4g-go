// Copyright 2025 atframework
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"

	utils_template "github.com/atframework/atframe-utils-go/template"
)

var initTemplate = `# This file is generated by tools/generate-for-pb tool.
configure:
  encoding: "UTF-8"
  output_directory: "{{ .project_build_dir }}"
  overwrite: false # overwrite file if it's already exists
  paths: []
  package_prefix: []
  protocol_input_pb_file: "{{ .protocol_input_pb_file }}"
  protocol_project_directory: "{{ .project_root_dir }}"
{{- with .protocol_external_pb_files }}
  protocol_external_pb_files: # external pb fils to load
  {{- range $_, $value := . }}
    - "{{ $value }}"
  {{- end }}
{{- end }}
{{- if not (empty .custom_variables) }}
  {{- with .custom_variables }}
  custom_variables:
    {{- range $key, $value := .custom_variables }}
    "{{ $key }}" : "{{ $value }}"
    {{- end }}
  {{- end }}
{{- end }}

rules:
{{- range $key, $value := .rules }}
  # rule for {{ $key }}
  {{- $value | trim | nindent 2 }}
{{- end }}
`

var basicTemplate *template.Template

// 项目配置结构.
type ProjectConfig struct {
	RootDir           string
	BuildDir          string
	GenDir            string
	Namespace         string
	TemplateDir       string
	ResourceTargetDir string
}

func getBasicTemplate() *template.Template {
	if basicTemplate != nil {
		return basicTemplate
	}

	basicTemplate = template.New("generate-for-pb").Funcs(utils_template.TemplateFuncMap())
	return basicTemplate
}

func renderServiceSettings(serviceTemplateFile string, rules *map[string]string, config *ProjectConfig) error {
	tmpl, err := template.ParseFiles(serviceTemplateFile)
	if err != nil {
		fmt.Printf("Failed to parse template file: %s\nerror: %v\n", serviceTemplateFile, err.Error())
		return err
	}

	output := new(bytes.Buffer)
	err = tmpl.Execute(output, map[string]interface{}{
		"project_root_dir":               strings.ReplaceAll(config.RootDir, "\\", "/"),
		"project_build_dir":              strings.ReplaceAll(config.BuildDir, "\\", "/"),
		"project_namespace":              config.Namespace,
		"project_current_configure_dir":  strings.ReplaceAll(filepath.Dir(serviceTemplateFile), "\\", "/"),
		"project_current_configure_file": serviceTemplateFile,
		"project_template_dir":           strings.ReplaceAll(config.TemplateDir, "\\", "/"),
	})
	if err != nil {
		fmt.Printf("Failed to parse template file: %s\nerror: %v\n", serviceTemplateFile, err.Error())
		return err
	}

	ruleContent := output.String()
	ruleContent = strings.TrimSpace(ruleContent)
	// 确保规则内容以 "- " 开头（作为 YAML 列表项）
	if !strings.HasPrefix(ruleContent, "- ") {
		ruleContent = "- " + ruleContent
	}

	// 使用规范化的路径作为 key（将反斜杠替换为正斜杠以保持一致）
	normalizedKey := strings.ReplaceAll(serviceTemplateFile, "\\", "/")
	(*rules)[normalizedKey] = ruleContent
	return nil
}

func generateFinalSettings(rules *map[string]string, config *ProjectConfig) ([]byte, error) {
	pbDir := filepath.Join(config.ResourceTargetDir, "pbdesc")

	pbFiles := []string{}
	err := filepath.WalkDir(pbDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			fmt.Printf("Failed to access path: %s\nerror: %v\n", path, err.Error())
			return err
		}

		if d.IsDir() {
			return nil
		}

		if filepath.Ext(d.Name()) == ".pb" {
			pbFiles = append(pbFiles, strings.ReplaceAll(path, "\\", "/"))
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to walk directory: %w", err)
	}

	if len(pbFiles) == 0 {
		return nil, fmt.Errorf("no .pb files found in directory: %s", pbDir)
	}

	// 对 pb 文件进行排序，确保生成的 YAML 内容一致
	slices.Sort(pbFiles)

	tmpl, err := getBasicTemplate().Parse(initTemplate)
	if err != nil {
		return nil, err
	}

	output := new(bytes.Buffer)
	err = tmpl.Execute(output, map[string]interface{}{
		"project_root_dir":           strings.ReplaceAll(config.RootDir, "\\", "/"),
		"project_build_dir":          strings.ReplaceAll(config.BuildDir, "\\", "/"),
		"protocol_input_pb_file":     strings.ReplaceAll(pbFiles[0], "\\", "/"),
		"protocol_external_pb_files": pbFiles[1:],
		"custom_variables":           map[string]string{},
		"rules":                      rules,
	})
	if err != nil {
		return nil, err
	}

	return output.Bytes(), nil
}

func writeFinalSettings(outputFile *os.File, newContent []byte) error {
	_, err := outputFile.Write(newContent)
	return err
}

// 比较两个规则集合是否相同（比较 key 和 value）
func rulesEqual(rules1, rules2 map[string]string) bool {
	// 首先检查 key 数量是否相同
	if len(rules1) != len(rules2) {
		return false
	}

	// 检查每个 key-value 对是否相同
	for key, value := range rules1 {
		if existingValue, exists := rules2[key]; !exists || existingValue != value {
			return false
		}
	}

	return true
}

func collectGenerateForPbTemplateFiles(scanDirs []string) []string {
	var templateFiles []string
	cache := make(map[string]bool)
	for _, dir := range scanDirs {
		err := filepath.WalkDir(dir, func(path string, d os.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				return nil
			}
			if !strings.HasPrefix(d.Name(), "generate-for-pb.atfw.") || (!strings.HasSuffix(d.Name(), ".yaml.tpl") && !strings.HasSuffix(d.Name(), ".yml.tpl")) {
				return nil
			}

			if _, ok := cache[path]; !ok {
				cache[path] = true
				// 规范化路径：反斜杠改为正斜杠，驱动器字母改为小写
				normalizedPath := strings.ReplaceAll(path, "\\", "/")
				// 处理 Windows 路径的驱动器字母大小写（如果是 X:/ 格式）
				if len(normalizedPath) >= 2 && normalizedPath[1] == ':' {
					normalizedPath = strings.ToLower(string(normalizedPath[0])) + normalizedPath[1:]
				}
				templateFiles = append(templateFiles, normalizedPath)
			}

			return nil
		})
		if err != nil {
			fmt.Println("Failed to scan directory: ", dir, " error: ", err.Error())
			return nil
		}
	}

	slices.SortFunc(templateFiles, func(a, b string) int {
		ba := filepath.Base(a)
		bb := filepath.Base(b)
		if ba != bb {
			return strings.Compare(ba, bb)
		}

		return strings.Compare(a, b)
	})
	return templateFiles
}

// 从现有文件中读取规则，用于增量更新时保留未被新模板覆盖的规则。
// 规则按模板文件路径作为 key 存储，规则内容包含完整的渲染输出（可能包含多个列表项）。
func loadExistingRules(filePath string) map[string]string {
	rules := make(map[string]string)

	content, err := os.ReadFile(filePath)
	if err != nil {
		// 文件不存在或无法读取，返回空规则
		return rules
	}

	contentStr := string(content)
	rulesIdx := strings.Index(contentStr, "rules:")
	if rulesIdx == -1 {
		return rules
	}

	// 提取 rules 部分（从 "rules:" 之后）
	rulesContent := contentStr[rulesIdx+6:]

	// 按行分割
	lines := strings.Split(rulesContent, "\n")

	var currentRuleKey string
	var currentRuleLines []string

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)

		// 遇到规则注释 "# rule for ..."
		if strings.HasPrefix(trimmedLine, "# rule for ") {
			// 保存前一个规则
			if currentRuleKey != "" && len(currentRuleLines) > 0 {
				// 归一化缩进：移除所有行的共同前导空格
				ruleContent := normalizeIndentation(currentRuleLines)
				rules[currentRuleKey] = ruleContent
			}
			// 提取新的 rule key
			currentRuleKey = strings.TrimSpace(strings.TrimPrefix(trimmedLine, "# rule for "))
			currentRuleLines = []string{}
			continue
		}

		// 如果当前处于规则内，收集所有非注释行
		if currentRuleKey != "" && trimmedLine != "" {
			// 不收集其他注释行（不是 "# rule for"）
			if !strings.HasPrefix(trimmedLine, "#") {
				currentRuleLines = append(currentRuleLines, line)
			}
		}
	}

	// 保存最后一个规则
	if currentRuleKey != "" && len(currentRuleLines) > 0 {
		ruleContent := normalizeIndentation(currentRuleLines)
		rules[currentRuleKey] = ruleContent
	}

	return rules
}

// normalizeIndentation 移除规则内容中所有行的共同前导空格。
// 这样当规则被应用 nindent 时，相对缩进会被正确保留。
func normalizeIndentation(lines []string) string {
	if len(lines) == 0 {
		return ""
	}

	// 找到最小的前导空格数（非空行）
	minIndent := -1
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed != "" && !strings.HasPrefix(trimmed, "#") {
			indent := len(line) - len(strings.TrimLeft(line, " "))
			if minIndent == -1 || indent < minIndent {
				minIndent = indent
			}
		}
	}

	if minIndent <= 0 {
		minIndent = 0
	}

	// 移除所有行的共同前导空格
	var result []string
	for _, line := range lines {
		if strings.TrimSpace(line) == "" {
			result = append(result, "")
		} else {
			// 移除前 minIndent 个空格
			if len(line) >= minIndent {
				result = append(result, line[minIndent:])
			} else {
				result = append(result, line)
			}
		}
	}

	return strings.TrimSpace(strings.Join(result, "\n"))
}

func main() {
	// 定义命令行参数
	rootDir := flag.String("root", "", "Project root directory")
	buildDir := flag.String("build", "", "Project build directory")
	genDir := flag.String("gen", "", "Generated files directory")
	namespace := flag.String("namespace", "", "Project namespace/package name")
	templateDir := flag.String("template", "", "Template directory")
	resourceDir := flag.String("resource", "", "Resource target directory")
	outputFile := flag.String("output", "", "Output file path (default: <gen>/generate-for-pb.yaml)")
	flag.Parse()

	// 验证必需参数
	if *rootDir == "" || *buildDir == "" || *genDir == "" || *namespace == "" || *templateDir == "" || *resourceDir == "" {
		fmt.Println("Error: Missing required parameters")
		fmt.Println("\nUsage:")
		flag.PrintDefaults()
		fmt.Println("\nExample:")
		fmt.Println("  go run . \\")
		fmt.Println("    --root /path/to/project \\")
		fmt.Println("    --build /path/to/project/build \\")
		fmt.Println("    --gen /path/to/project/build/_gen \\")
		fmt.Println("    --namespace github.com/example/project \\")
		fmt.Println("    --template /path/to/project/src/template \\")
		fmt.Println("    --resource /path/to/project/build/install/resource \\")
		fmt.Println("    [scan_dir1 scan_dir2 ...]")
		os.Exit(1)
		return
	}

	config := &ProjectConfig{
		RootDir:           *rootDir,
		BuildDir:          *buildDir,
		GenDir:            *genDir,
		Namespace:         *namespace,
		TemplateDir:       *templateDir,
		ResourceTargetDir: *resourceDir,
	}

	// 确定输出文件路径
	outputFilePath := *outputFile
	if outputFilePath == "" {
		outputFilePath = filepath.Join(config.GenDir, "generate-for-pb.yaml")
	}

	// 读取现有文件中的规则（如果存在），用于增量更新
	rules := loadExistingRules(outputFilePath)
	fmt.Printf("Starting with %d existing rules\n", len(rules))

	// 确定扫描目录
	var scanDirs []string
	if flag.NArg() == 0 {
		scanDirs = []string{filepath.Join(config.RootDir, "src")}
	} else {
		scanDirs = flag.Args()
	}

	// 处理新的模板文件，新规则会覆盖旧规则
	serviceTemplateFiles := collectGenerateForPbTemplateFiles(scanDirs)
	for _, serviceTemplateFile := range serviceTemplateFiles {
		fmt.Printf("Processing template file: %s\n", serviceTemplateFile)
		if err := renderServiceSettings(serviceTemplateFile, &rules, config); err != nil {
			fmt.Printf("Failed to render settings: %v\n", err)
			os.Exit(1)
			return
		}
	}

	// 生成新的内容
	newContent, err := generateFinalSettings(&rules, config)
	if err != nil {
		fmt.Printf("Failed to generate settings: %v\n", err)
		os.Exit(1)
		return
	}

	// 比较规则的 key 和 value 是否相同
	existingRules := loadExistingRules(outputFilePath)
	if rulesEqual(rules, existingRules) {
		fmt.Println("Rules content is identical, skipping write")
		return
	}

	if len(existingRules) == 0 {
		fmt.Printf("No existing file or rules, will create it\n")
	}

	// 内容不同或文件不存在，进行写入
	outFile, err := os.OpenFile(outputFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o664)
	if err != nil {
		fmt.Printf("Open file: %s failed.\n%v\n", outputFilePath, err.Error())
		os.Exit(1)
		return
	}
	defer outFile.Close()

	if err := writeFinalSettings(outFile, newContent); err != nil {
		os.Exit(1)
		return
	}

	fmt.Println("Output file written successfully")
}
